<!DOCTYPE html>
<html lang="en">

<!--
    Author: sepp89117
    Version: 2.0
    Date: 2024-02-25
-->

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>GoPro BLE RC</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        /* #1c1c1c dark gray; #4d4d4d gray; #005eab blue; #009fe0 light blue; #fff wihte */
        html {
            font-family: Segoe UI, Frutiger, Frutiger Linotype, Dejavu Sans, Helvetica Neue, Arial, sans-serif;
            text-align: center;
            background-color: #131313;
            color: #fff;
        }

        input,
        select {
            background-color: #252525;
            color: #fff;
            border: 1px solid #666;
            border-radius: 3px;
            padding: 8px;
            margin: 5px 2px;
            font-weight: bold;
        }

        .list-btn {
            margin: 0;
        }

        input:hover {
            background-color: #003561;
            transition: .3s;
        }

        legend {
            margin: 0;
            padding-left: 6px;
        }

        fieldset {
            display: block;
            margin-bottom: 10px;
            background-color: #151522;
            border-radius: 3px;
            border-color: #666;
            border-left: none;
            border-right: none;
            border-bottom: none;
        }

        fieldset div {
            /* display: inline-block; */
            margin: -5px;
        }

        .h2 {
            font-size: 1.2rem;
        }

        p {
            font-size: 1.0rem;
        }

        body {
            max-width: 600px;
            margin: 0px auto;
        }

        fieldset.foldable {
            height: 0px;
            overflow: hidden;
            padding-bottom: 0;
        }

        fieldset.foldable.expanded {
            height: auto;
            padding-bottom: 10px;
        }

        fieldset.foldable>legend::after {
            content: "+";
            margin: 0px 5px 0px 10px;
            padding: 0px 8px 5px 8px;
            background-color: #252525;
            border: 1px solid #666;
            border-radius: 3px;
            cursor: default;
            display: inline-block;
            width: 11px;
            text-align: center;
        }

        fieldset.foldable.expanded>legend::after {
            content: "-";
            margin: 0px 5px 0px 10px;
            padding: 0px 8px 5px 8px;
            background-color: #252525;
            border: 1px solid #666;
            border-radius: 3px;
            cursor: default;
            display: inline-block;
            width: 11px;
            text-align: center;
        }

        .styled-table {
            border-collapse: collapse;
            margin: 10px 0;
            font-size: 0.9em;
            width: 100%;
        }

        .styled-table td {
            padding: 0;
        }

        .styled-table th {
            padding: 0px 5px;
        }

        .styled-table .cam-th {
            border-right: 1px solid #fff;
        }

        .styled-table .cam-td {
            border-right: 1px solid #fff;
            text-align: left;
        }

        .styled-table .cam-td span {
            margin: 0px 5px;
            white-space: nowrap;
        }

        .styled-table .cam-td div {
            display: block;
            margin: 2px 0px;
            padding: 2px;
        }

        .styled-table thead tr {
            background-color: #2d2d2d;
            color: #ffffff;
        }

        .styled-table tbody tr {
            border-bottom: 1px solid #dddddd;
            background-color: #3d3d3d;
        }

        .styled-table tbody tr:nth-of-type(even) {
            background-color: #1c1c1c;
        }

        .styled-table tbody tr:last-of-type {
            border-bottom: 2px solid #2d2d2d;
        }

        .menu {
            width: fit-content;
            padding: 6px 4px 2px 4px;
            background-color: #1c1c1c;
            transition: .3s;
            position: absolute;
            list-style: none;
            border-radius: 3px;
        }

        .menu-title {
            margin: -6px -4px 15px -4px;
            border-bottom: 2px solid white;
            padding: 6px;
            border-radius: 3px;
            background-color: #004073;
            font-size: 10pt;
            color: white;
            border-top: 2px solid white;
        }

        .has-submenu::after {
            content: "\25BC";
            float: right;
            margin-left: 5px;
        }

        .item {
            border-top: 2px solid #fff;
            border-bottom: 2px solid #fff;
            border-radius: 4px;
            background: #4d4d4d;
            overflow: hidden;
            list-style: none;
            padding: 5px;
            margin-bottom: 4px;
            cursor: pointer;
        }

        .item:hover {
            background: #005eab;
            transition: .3s;
        }

        .menu .submenu {
            display: none;
            position: absolute;
            background-color: #1c1c1c;
            padding: 0px;
            color: white;
            border-radius: 3px;
            left: -20px;
            margin-top: 7px;
        }

        .menu .has-submenu:hover .submenu,
        .menu .has-submenu:active .submenu,
        .menu .has-submenu:focus .submenu {
            display: block;
        }

        .has-submenu:hover::after,
        .has-submenu:active::after,
        .has-submenu:focus::after {
            content: "\25B2";
        }

        .rec_btn {
            padding: 8px 8px 8px 32px;
        }

        .rec_btn:hover {
            border: 1px solid #c80000
        }

        .stop_btn {
            padding: 8px 8px 8px 32px;
        }

        .stop_btn:hover {
            border: 1px solid #c80000
        }

        .highlight_btn {
            padding: 8px 8px 8px 24px;
        }

        .highlight_btn:hover {
            border: 1px solid #ffe100
        }

        .wifi_on_btn,
        .wifi_off_btn,
        .sleep_btn {
            padding: 8px 8px 8px 32px;
        }

        .wifi_on_btn:hover,
        .wifi_off_btn:hover,
        .sleep_btn:hover {
            border: 1px solid #009fe0
        }
    </style>
</head>

<body style="padding: 10px;">
    <div style="display: flex; justify-content: space-between;">
        <span style="padding: 0;">
            <img src="logo.png" width="36" height="36">
            <b class="h2" style="vertical-align: super;margin-left: 5px;">GoPro Web RC</b>
            <span style="vertical-align: super;margin-left: 5px;">v2.0</span>
        </span>
        <input type="button" onclick="onClickPair();" value="Connect/Pair new">
    </div>
    <span id="status"
        style="display: block;min-height: 22px;margin: -5px 0 7px 0;color:#ffbf00;text-align: left;"></span>
    <fieldset>
        <legend style="text-align: left;"><b>Control</b></legend>
        <div>
            <input type="button" class="rec_btn" onclick="sendCommand(shutterOn);" value="rec">
            <input type="button" class="stop_btn" onclick="sendCommand(shutterOff);" value="stop">
            <input type="button" class="highlight_btn" onclick="sendCommand(hilight);" value="hilight"><br>
            <input type="button" class="wifi_on_btn" onclick="sendCommand(wiFiAPoff);" value="WiFi AP: off">
            <input type="button" class="wifi_off_btn" onclick="sendCommand(wiFiAPon);" value="WiFi AP: on">
            <input type="button" class="sleep_btn" onclick="sendCommand(camSleep);" value="Put camera to sleep">
            <label style="display: block;">
                Preset
                <select style="margin-top: 10px;">
                    <option value="videoGroup">Video Group</option>
                    <option value="photoGroup">Photo Group</option>
                    <option value="timelapseGroup">Timelapse Group</option>
                    <option value="standard">Standard</option>
                    <option value="activity">Activity</option>
                    <option value="cinematic">Cinematic</option>
                    <option value="photo">Photo</option>
                    <option value="liveBurst">Live Burst</option>
                    <option value="burstPhoto">Burst Photo</option>
                    <option value="nightPhoto">Night Photo</option>
                    <option value="timeWarp">Time Warp</option>
                    <option value="timeLapse">Time Lapse</option>
                    <option value="nightLapse">Night Lapse</option>
                </select>
                <input type="button"
                    onclick="sendCommand(presetCmds[this.previousElementSibling.selectedOptions[0].value]);"
                    value="Load">
            </label>
        </div>
    </fieldset>
    <fieldset class="foldable expanded">
        <legend style="text-align: left;"
            onclick="this.parentNode.classList.toggle('expanded'); PopupMenu.removeMenu();">
            <b>Connected devices</b>
        </legend>
        <table id="dev_list" class="styled-table">
            <thead>
                <tr>
                    <th class="cam-th">Cam</th>
                    <th style="width: 86px;">Menu</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td colspan="100%">No device connected</td>
                </tr>
            </tbody>
        </table>
    </fieldset>
    <fieldset id="errorLog" class="foldable">
        <legend style="text-align: left;" onclick="this.parentNode.classList.toggle('expanded');"><b>Error Log</b>
        </legend>
        <table id="error_log_table" class="styled-table">
            <thead>
                <tr>
                    <th class="cam-th" style="width: 140px;">Timestamp</th>
                    <th style="text-align: left;padding-left: 10px;">Message</th>
                </tr>
            </thead>
            <tbody>
            </tbody>
        </table>
    </fieldset>

</body>

<script>
    // SVG symbols
    const rec_symbol_svg = '<svg id="rec_symbol" width="18" height="18" viewBox="0 0 4.7624954 4.7625" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"><g transform="translate(-51.785523,-48.013297)"><ellipse style="fill:none;stroke:#c80000;stroke-width:0.829985" cx="54.166771" cy="50.394547" rx="1.9662552" ry="1.9662573" /></g></svg>';
    const stop_symbol_svg = '<svg id="stop_symbol" width="18" height="18" viewBox="0 0 4.7629955 4.763" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"><g transform="translate(-51.785523,-48.013297)"><rect style="fill:none;stroke:#c80000;stroke-width:0.829648;stroke-dasharray:none" width="3.9328516" height="3.9328513" x="52.200348" y="48.42812" /></g></svg>';
    const highlight_symbol_svg = '<svg id="highlight_symbol" width="18" height="18" viewBox="0 0 4.7624954 4.7625" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"><g transform="translate(-51.785523,-48.013297)"><path id="rect1" style="fill:none;stroke:#ffe101;stroke-width:0.422795;stroke-opacity:1" d="m 52.989109,48.530329 1.194336,1.178087 1.160994,-1.178087 8.4e-5,2.910727 -1.177792,1.051101 -1.177208,-1.051101 z" /></g></svg>';
    const wifi_on_symbol_svg = '<svg id="wifi_on_symbol" width="18" height="18" viewBox="0 0 18 18" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"><path fill="@android:color/white" d="m 0,6.7247727 1.6363636,1.6363637 c 4.0663637,-4.0663637 10.6609094,-4.0663637 14.7272724,0 L 18,6.7247727 c -4.966364,-4.9663636 -13.0254545,-4.9663636 -18,0 z M 6.5454545,13.270227 9,15.724773 11.454545,13.270227 c -1.35,-1.358182 -3.5509086,-1.358182 -4.9090905,0 z M 3.2727273,9.9975 4.9090909,11.633864 c 2.2581818,-2.258182 5.9236361,-2.258182 8.1818181,0 L 14.727273,9.9975 c -3.158182,-3.1581818 -8.2881821,-3.1581818 -11.4545457,0 z" id="path_0" style="stroke-width:0.818182;fill:#009fe0;fill-opacity:1" /></svg>';
    const wifi_off_symbol_svg = '<svg id="wifi_off_symbol" width="18" height="18" viewBox="0 0 18 18" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"><path fill="@android:color/white" d="M 18,6.7017735 C 14.856753,3.5585266 10.47749,2.4125512 6.4174625,3.2474761 L 8.4802183,5.3102319 C 11.3206,5.1710778 14.20191,6.1697135 16.362892,8.338881 Z M 14.725784,9.975989 C 13.66985,8.920055 12.401091,8.232469 11.050477,7.880491 l 2.889496,2.889495 z M 0.8185539,1.8313779 3.3315143,4.3279673 C 2.1282401,4.9173261 0.99863574,5.7031378 0,6.7017735 L 1.6289222,8.338881 C 2.6439291,7.3238745 3.8144611,6.5708049 5.0668486,6.071487 L 6.9004093,7.905048 C 5.574352,8.24884 4.313779,8.936426 3.2742156,9.975989 v 0.0082 l 1.6289222,1.628922 C 6.0163711,10.499878 7.473397,9.943261 8.9304229,9.92689 L 14.717599,15.70588 15.757162,14.674502 1.8744884,0.8 Z m 5.7298772,11.4188271 2.4556619,2.455661 2.455661,-2.455661 c -1.350613,-1.3588 -3.5525234,-1.3588 -4.9113229,0 z" id="path_0" style="fill:#009fe0;fill-opacity:1;stroke-width:0.818554" /></svg>';
    const sleep_symbol_svg = '<svg id="sleep_symbol" width="18" height="18" viewBox="0 0 768 768" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"><path fill="#009FE0FF" d="m 365.64171,701.55675 a 68.885187,65.589671 0 0 0 -26.39912,-3.53477 h -40.91863 l 70.20515,-77.68645 a 61.542934,58.598675 0 0 0 19.55184,-39.74655 c 0,-25.13616 -16.08695,-38.17555 -49.33334,-39.98221 H 230.26375 a 49.333344,46.973201 0 0 0 -26.39911,5.81273 35.886295,34.169469 0 0 0 -16.91193,29.14224 34.56634,32.912661 0 0 0 22.43924,31.18456 57.253078,54.51405 0 0 0 26.39912,3.29911 h 34.81383 l -77.3824,84.67745 a 52.798228,50.272322 0 0 0 -15.26199,34.48367 37.206251,35.426277 0 0 0 16.66444,30.9489 47.765897,45.480741 0 0 0 30.35898,7.54085 h 121.93091 a 36.133787,34.40512 0 0 0 40.91863,-34.71933 34.56634,32.912661 0 0 0 -22.19176,-31.4202 z M 735.2293,500.46747 a 101.38909,96.538569 0 0 0 -38.03122,-5.02724 h -86.2921 L 736.79675,356.17019 a 91.324434,86.955408 0 0 0 29.864,-59.54128 c 0,-53.25725 -52.79823,-56.08506 -71.77259,-56.79202 H 518.50908 a 73.917519,70.381252 0 0 0 -38.7737,8.32636 50.158316,47.758707 0 0 0 -23.26422,40.68916 48.343377,46.030595 0 0 0 31.43144,43.51697 86.292103,82.163827 0 0 0 38.03123,4.79159 h 74.74249 L 465.21587,487.97793 a 77.382403,73.680373 0 0 0 -23.26422,50.27232 52.798228,50.272322 0 0 0 23.51171,43.98829 69.462668,66.139524 0 0 0 44.631,10.52576 h 199.31331 a 58.07805,55.299554 0 0 0 52.79822,-25.13615 57.005587,54.278398 0 0 0 5.77481,-23.40805 48.013388,45.716393 0 0 0 -32.17392,-44.45959 z M 381.72867,359.94061 A 124.90081,118.92546 0 0 0 336.0252,354.12788 H 177.63052 L 377.7688,132.694 a 110.3813,105.10057 0 0 0 36.95876,-71.16675 c 0,-58.2844737 -55.19064,-60.0911352 -81.34227,-61.34794334 H 87.873532 A 82.662225,78.707605 0 0 0 43.490026,9.2126143 51.23078,48.779862 0 0 0 20.060812,50.530179 48.590869,46.266247 0 0 0 52.234731,94.989767 103.20404,98.26668 0 0 0 98.268184,100.8025 H 241.31838 L 28.310535,336.29691 A 89.262003,84.991645 0 0 0 0.09648171,394.58138 54.613167,52.000433 0 0 0 24.928149,441.31893 79.197342,75.408484 0 0 0 75.911437,452.63021 H 350.95721 a 62.862889,59.855484 0 0 0 57.83055,-25.13617 59.645497,56.792014 0 0 0 6.1048,-25.13615 48.013388,45.716393 0 0 0 -32.9989,-42.49583 z" id="path_0" style="stroke-width:0.804997;fill:#009fe0;fill-opacity:1;stroke:none;stroke-opacity:1" /></svg>';

    // Cam menu
    const cam_menu_items = [
        {
            label: "Single Control",
            type: "title"
        },
        {
            label: "rec",
            icon: {
                type: "url",
                src: getSvgUrl(rec_symbol_svg)
            },
            onclick: function () {
                bufferBtAction(sendCommandToSingle, [shutterOn, this.parentNode.parentNode.dataset.sender_id]);
            }
        },
        {
            label: "stop",
            icon: {
                type: "url",
                src: getSvgUrl(stop_symbol_svg)
            },
            onclick: function () {
                bufferBtAction(sendCommandToSingle, [shutterOff, this.parentNode.parentNode.dataset.sender_id]);
            }
        },
        {
            label: "highlight",
            icon: {
                type: "url",
                src: getSvgUrl(highlight_symbol_svg)
            },
            onclick: function () {
                bufferBtAction(sendCommandToSingle, [hilight, this.parentNode.parentNode.dataset.sender_id]);
            }
        },
        {
            label: "WiFi AP on",
            icon: {
                type: "url",
                src: getSvgUrl(wifi_on_symbol_svg)
            },
            onclick: function () {
                bufferBtAction(sendCommandToSingle, [wiFiAPon, this.parentNode.parentNode.dataset.sender_id]);
            }
        },
        {
            label: "WiFi AP off",
            icon: {
                type: "url",
                src: getSvgUrl(wifi_off_symbol_svg)
            },
            onclick: function () {
                bufferBtAction(sendCommandToSingle, [wiFiAPoff, this.parentNode.parentNode.dataset.sender_id]);
            }
        },
        {
            label: "Put camera to sleep",
            icon: {
                type: "url",
                src: getSvgUrl(sleep_symbol_svg)
            },
            onclick: function () {
                bufferBtAction(sendCommandToSingle, [camSleep, this.parentNode.parentNode.dataset.sender_id]);
            }
        },
        {
            label: "Locate on",
            onclick: function () {
                bufferBtAction(sendCommandToSingle, [locateOn, this.parentNode.parentNode.dataset.sender_id]);
            }
        },
        {
            label: "Locate off",
            onclick: function () {
                bufferBtAction(sendCommandToSingle, [locateOff, this.parentNode.parentNode.dataset.sender_id]);
            }
        },
        {
            label: "Presets",
            items: [
                {
                    label: "Video Group",
                    onclick: function () {
                        bufferBtAction(sendCommandToSingle, [presetCmds['videoGroup'], this.parentNode.parentNode.dataset.sender_id]);
                    }
                },
                {
                    label: "Photo Group",
                    onclick: function () {
                        bufferBtAction(sendCommandToSingle, [presetCmds['photoGroup'], this.parentNode.parentNode.dataset.sender_id]);
                    }
                },
                {
                    label: "Timelapse Group",
                    onclick: function () {
                        bufferBtAction(sendCommandToSingle, [presetCmds['timelapseGroup'], this.parentNode.parentNode.dataset.sender_id]);
                    }
                },
                {
                    label: "Standard",
                    onclick: function () {
                        bufferBtAction(sendCommandToSingle, [presetCmds['standard'], this.parentNode.parentNode.dataset.sender_id]);
                    }
                },
                {
                    label: "Activity",
                    onclick: function () {
                        bufferBtAction(sendCommandToSingle, [presetCmds['activity'], this.parentNode.parentNode.dataset.sender_id]);
                    }
                },
                {
                    label: "Cinematic",
                    onclick: function () {
                        bufferBtAction(sendCommandToSingle, [presetCmds['cinematic'], this.parentNode.parentNode.dataset.sender_id]);
                    }
                },
                {
                    label: "Photo",
                    onclick: function () {
                        bufferBtAction(sendCommandToSingle, [presetCmds['photo'], this.parentNode.parentNode.dataset.sender_id]);
                    }
                },
                {
                    label: "Live Burst",
                    onclick: function () {
                        bufferBtAction(sendCommandToSingle, [presetCmds['liveBurst'], this.parentNode.parentNode.dataset.sender_id]);
                    }
                },
                {
                    label: "Burst Photo",
                    onclick: function () {
                        bufferBtAction(sendCommandToSingle, [presetCmds['burstPhoto'], this.parentNode.parentNode.dataset.sender_id]);
                    }
                },
                {
                    label: "Night Photo",
                    onclick: function () {
                        bufferBtAction(sendCommandToSingle, [presetCmds['nightPhoto'], this.parentNode.parentNode.dataset.sender_id]);
                    }
                },
                {
                    label: "Time Warp",
                    onclick: function () {
                        bufferBtAction(sendCommandToSingle, [presetCmds['timeWarp'], this.parentNode.parentNode.dataset.sender_id]);
                    }
                },
                {
                    label: "Time Lapse",
                    onclick: function () {
                        bufferBtAction(sendCommandToSingle, [presetCmds['timeLapse'], this.parentNode.parentNode.dataset.sender_id]);
                    }
                },
                {
                    label: "Night Lapse",
                    onclick: function () {
                        bufferBtAction(sendCommandToSingle, [presetCmds['nightLapse'], this.parentNode.parentNode.dataset.sender_id]);
                    }
                },
            ]
        }
    ];

    // Custom GoPro services
    const controlServiceUUID = "0000fea6-0000-1000-8000-00805f9b34fb"; // Cam control service
    const wifiServiceUUID = "b5f90001-aa8d-11e3-9046-0002a5d5c51b";    // GoPro WiFi Access Point
    const nwManServiceUUID = "b5f90090-aa8d-11e3-9046-0002a5d5c51b";     // Query [WRITE]
    // Standard services
    const defInfoUUID = "0000180a-0000-1000-8000-00805f9b34fb";  // Device information
    // Custom GoPro characteristics
    const commandUUID = "b5f90072-aa8d-11e3-9046-0002a5d5c51b";       // Command [WRITE]
    const commandRespUUID = "b5f90073-aa8d-11e3-9046-0002a5d5c51b";   // Command response [NOTIFY]
    const settingsUUID = "b5f90074-aa8d-11e3-9046-0002a5d5c51b";      // Settings [WRITE]
    const settingsRespUUID = "b5f90075-aa8d-11e3-9046-0002a5d5c51b";  // Settings response [NOTIFY]
    const queryUUID = "b5f90076-aa8d-11e3-9046-0002a5d5c51b";         // Query [WRITE]
    const queryRespUUID = "b5f90077-aa8d-11e3-9046-0002a5d5c51b";     // Query response [NOTIFY]
    const nwManCmdUUID = "b5f90091-aa8d-11e3-9046-0002a5d5c51b";     // Query [WRITE]
    const nwManRespUUID = "b5f90092-aa8d-11e3-9046-0002a5d5c51b";     // Query response [NOTIFY]
    const wifiSsidUUID = "b5f90002-aa8d-11e3-9046-0002a5d5c51b";      // Wifi [READ | WRITE]
    const wifiPwUUID = "b5f90003-aa8d-11e3-9046-0002a5d5c51b";        // Wifi [READ | WRITE]
    const wifiStateUUID = "b5f90005-aa8d-11e3-9046-0002a5d5c51b";        // Wifi [READ | INDICATE]
    // Standard characteristics
    const modelNoUUID = "00002a24-0000-1000-8000-00805f9b34fb";   // Model number

    /*
    * Protobuf
    */
    const featureIDs = [0x02 /* NETWORK_MANAGEMENT */, 0xF1 /* COMMAND */, 0xF3 /* SETTING */, 0xF5 /* QUERY */];
    // RELEASE_NETWORK_RSP = 0xF8
    const actionIDs = [
        /* NETWORK_MANAGEMENT */
        [0x02 /* SCAN_WIFI_NETWORKS */, 0x03 /* GET_AP_ENTRIES */, 0x04 /* REQUEST_WIFI_CONNECT */, 0x05 /* REQUEST_WIFI_CONNECT_NEW */, 0x0B /* NOTIF_START_SCAN */, 0x0C /* NOTIF_PROVIS_STATE */, 0x78 /* RELEASE_NETWORK */, 0x82 /* SCAN_WIFI_NETWORKS_RSP */, 0x83 /* GET_AP_ENTRIES_RSP */, 0x84 /* REQUEST_WIFI_CONNECT_RSP */, 0x85 /* REQUEST_WIFI_CONNECT_NEW_RSP */, 0xF8 /* RELEASE_NETWORK_RSP */],
        /* COMMAND */
        [0x69 /* SET_CAMERA_CONTROL */, 0x6B /* SET_TURBO_MODE */, 0x79 /* SET_LIVESTREAM_MODE */, 0xE9 /* SET_CAMERA_CONTROL_RSP */, 0xEB /* SET_TURBO_MODE_RSP */, 0xF9 /* SET_LIVESTREAM_MODE_RSP */],
        /* SETTING */
        [],
        /* QUERY */
        [0x72 /* GET_PRESET_STATUS */, 0x74 /* GET_LIVESTREAM_STATUS */, 0xF2 /* GET_PRESET_STATUS_RSP */, 0xF3 /* PRESET_MODIFIED_NOTIFICATION */, 0xF4 /* LIVESTREAM_STATUS_RSP */, 0xF5 /* LIVESTREAM_STATUS_NOTIF */]
    ];

    /*
    * BT-Commands
    */
    // Settings (0x0074)
    var keepAlive = Uint8Array.from([0x03, 0x5B, 0x01, 0x42]); // Only Hero 9 and 10 ? Hero 8 response is Error
    // Commands (0x0072)
    var shutterOff = Uint8Array.from([0x03, 0x01, 0x01, 0x00]);
    var shutterOn = Uint8Array.from([0x03, 0x01, 0x01, 0x01]);
    var camSleep = Uint8Array.from([0x01, 0x05]);
    var locateOff = Uint8Array.from([0x03, 0x16, 0x01, 0x00]);
    var locateOn = Uint8Array.from([0x03, 0x16, 0x01, 0x01]);
    var wiFiAPoff = Uint8Array.from([0x03, 0x17, 0x01, 0x00]);
    var wiFiAPon = Uint8Array.from([0x03, 0x17, 0x01, 0x01]);
    var hilight = Uint8Array.from([0x01, 0x18]);
    var presetCmds = {
        "videoGroup": Uint8Array.from([0x04, 0x3E, 0x02, 0x03, 0xE8]),
        "photoGroup": Uint8Array.from([0x04, 0x3E, 0x02, 0x03, 0xE9]),
        "timelapseGroup": Uint8Array.from([0x04, 0x3E, 0x02, 0x03, 0xEA]),
        "standard": Uint8Array.from([0x06, 0x40, 0x04, 0x00, 0x00, 0x00, 0x00]),
        "activity": Uint8Array.from([0x06, 0x40, 0x04, 0x00, 0x00, 0x00, 0x01]),
        "cinematic": Uint8Array.from([0x06, 0x40, 0x04, 0x00, 0x00, 0x00, 0x02]),
        "photo": Uint8Array.from([0x06, 0x40, 0x04, 0x00, 0x01, 0x00, 0x00]),
        "liveBurst": Uint8Array.from([0x06, 0x40, 0x04, 0x00, 0x01, 0x00, 0x01]),
        "burstPhoto": Uint8Array.from([0x06, 0x40, 0x04, 0x00, 0x01, 0x00, 0x02]),
        "nightPhoto": Uint8Array.from([0x06, 0x40, 0x04, 0x00, 0x01, 0x00, 0x03]),
        "timeWarp": Uint8Array.from([0x06, 0x40, 0x04, 0x00, 0x02, 0x00, 0x00]),
        "timeLapse": Uint8Array.from([0x06, 0x40, 0x04, 0x00, 0x02, 0x00, 0x01]),
        "nightLapse": Uint8Array.from([0x06, 0x40, 0x04, 0x00, 0x02, 0x00, 0x02])
    }
    var getHardwareInfo = Uint8Array.from([0x01, 0x3C]);

    // Querys (0x0076)
    var qSpace = Uint8Array.from([0x02, 0x13, 0x36]);
    var qPreset = Uint8Array.from([0x02, 0x13, 0x61]);
    var registerForAllStatusValueUpdates = Uint8Array.from([0x01, 0x53]);
    var queryAllStatusValues = Uint8Array.from([0x01, 0x13]);

    // TODO get all GoPro model IDs
    var gopro_models = {
        62: "Hero 12",
        60: "Hero 11 Black Mini",
        58: "Hero 11 Black",
        57: "Hero 10 Black",
        55: "Hero 9 Black",
        51: "GoPro Max",
        50: "Hero 8 Black",
        30: "Hero 7 Black",
        24: "Hero 6 Black",
        21: "Hero 5 Session",
        19: "Hero 5 Black",
    }
    var presets = {
        0x00000000: "Standard",
        0x00000001: "Activity",
        0x00000002: "Cinematic",
        0x00000003: "Slo-Mo",
        0x00000004: "Ultra Slo-Mo",
        0x00000005: "Basic",
        0x00010000: "Photo",
        0x00010001: "Live Burst",
        0x00010002: "Burst Photo",
        0x00010003: "Night Photo",
        0x00020000: "Time Warp",
        0x00020001: "Time Lapse",
        0x00020002: "Night Lapse",
        0x00030000: "Max Video",
        0x00040000: "Max Photo",
        0x00050000: "Max Timewarp",
    }
    var connectingDev = null;
    var connectedDevs = [];
    const dev_list = document.getElementById("dev_list");
    var btActionBuffer = [];
    var execMillis = 0;
    const MTU = 20;

    window.onerror = function (message, source, lineno, colno, error) {
        logError("Unhandled error: " + message + " on Line " + lineno + ":" + colno + " in " + source);
        return true;
    };

    window.addEventListener("DOMContentLoaded", function () {
        styleButtons();
        showInfo("Click on 'Connect/Pair new'", 0);
        execMillis = new Date();
        bufferExecNext(); //starts the buffered execution of BT actions
        window.setInterval(intervalActions, 250);
        logError("Program started")
    });

    function styleButtons() {
        const rec_btn = document.querySelector(".rec_btn");
        rec_btn.style.cssText += 'background: #252525 url("' + getSvgUrl(rec_symbol_svg) + '") no-repeat 6px 5.5px;background-size: 20px;';

        const stop_btn = document.querySelector(".stop_btn");
        stop_btn.style.cssText += 'background: #252525 url("' + getSvgUrl(stop_symbol_svg) + '") no-repeat 7px 6.5px;background-size: 18px;';

        const highlight_btn = document.querySelector(".highlight_btn");
        highlight_btn.style.cssText += 'background: #252525 url("' + getSvgUrl(highlight_symbol_svg) + '") no-repeat 2.5px 5px;background-size: 20px;';

        const wifi_on_btn = document.querySelector(".wifi_on_btn");
        wifi_on_btn.style.cssText += 'background: #252525 url("' + getSvgUrl(wifi_on_symbol_svg) + '") no-repeat 6px 5.5px;background-size: 18px;';

        const wifi_off_btn = document.querySelector(".wifi_off_btn");
        wifi_off_btn.style.cssText += 'background: #252525 url("' + getSvgUrl(wifi_off_symbol_svg) + '") no-repeat 6px 5.5px;background-size: 18px;';

        const sleep_btn = document.querySelector(".sleep_btn");
        sleep_btn.style.cssText += 'background: #252525 url("' + getSvgUrl(sleep_symbol_svg) + '") no-repeat 6px 5.5px;background-size: 18px;';
    }

    /*
    *   Pairing / Connecting
    */
    function onClickPair() {
        if (connectingDev != null) {
            showInfo("A connect process with '" + connectingDev.name + "' is already in progress!", 3000);
            return;
        } else if (navigator.bluetooth === undefined) {
            showInfo('Bluetooth is not supported by your browser! Check the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Bluetooth_API#browser_compatibility" style="color: antiquewhite;">Browser Compatibility</a> for compatible browsers', 0);
            return;
        }
        let filters = [];
        let options = {};

        filters.push({ services: [controlServiceUUID] });
        options.filters = filters;
        options.optionalServices = [controlServiceUUID, defInfoUUID, wifiServiceUUID, nwManServiceUUID];

        console.log('Requesting Bluetooth Device...');
        console.log('with ' + JSON.stringify(options));

        navigator.bluetooth.requestDevice(options)
            .then(device => {
                if (device.name === null) {
                    showInfo("Device name is 'null'! Is the camera paired with your device via Bluetooth?", 6000);
                    logError("[navigator.bluetooth.requestDevice] Device name is 'null'");
                    resetConnectingDev();
                    return;
                }
                console.log("Connecting to '" + device.name + "'.");
                showInfo("Connecting to '" + device.name + "'. Make sure the camera is powered on and wait...", 0);

                // Check if device is always conencted
                for (var i = 0; i < connectedDevs.length; i++) {
                    if (connectedDevs[i].server.device.id == device.id && connectedDevs[i].server.connected) {
                        showInfo("'" + device.name + "' is always connected!", 3000);
                        return; // device is always connected
                    }
                }

                // Timeout 60s for connect()
                connectingDev = device;
                window.setTimeout(function () {
                    if (connectingDev != null) {
                        showInfo("Connecting '" + connectingDev.name + "' timeout! Please retry!", 5000);
                        resetConnectingDev();
                    }
                }, 60000);
                return device.gatt.connect();
            })
            .then(server => {
                if (server == null) {
                    logError("[gatt.connect] Server is 'null'");
                    return;
                }
                connectingDev = null;
                console.log('GATT connected');

                var goProDevice = {
                    server: server,
                    Name: server.device.name,
                    Model: "?",
                    ModelID: 0,
                    Preset: "N/A",
                    Battery: "?",
                    Memory: "?",
                    WifiSsid: "?",
                    WifiPw: "?",
                    WifiState: "?",
                    isBusy: false,
                    isRecording: false,
                    isCharging: false,
                    isHot: false,
                    isCold: false,
                    videoProgress: 0,
                    autoValueUpdatesRegistered: false,
                    LE: "None", // last error
                    lastKeepAlive: new Date(),
                    lastPresetQuery: new Date(),
                    lastMemoryQuery: new Date(),
                    lastBatteryRead: new Date(),
                };
                goProDevice.server.device.addEventListener('gattserverdisconnected', onDisconnected);

                // Save connected cam in array
                connectedDevs.push(goProDevice);
                showInfo("Cam '" + goProDevice.Name + "' connected!", 3000);
                console.log('Getting Services...');
                return server.getPrimaryServices();
            })
            .then(service => {
                if (service == null) {
                    logError("[getPrimaryServices] Service is 'null'");
                    return;
                }

                for (var d = 0; d < connectedDevs.length; d++) {
                    if (connectedDevs[d].server.device.id == service[0].device.id) {
                        connectedDevs[d].services = service;
                        var dev = connectedDevs[d];

                        for (var i = 0; i < dev.services.length; i++) {
                            var service = dev.services[i];

                            switch (service.uuid) {
                                case controlServiceUUID:
                                    console.log('Got control Service');
                                    console.log('Getting control Characteristics...');
                                    bufferBtAction(getCharacteristic, [service, commandUUID]);
                                    bufferBtAction(getCharacteristic, [service, commandRespUUID]);
                                    bufferBtAction(getCharacteristic, [service, settingsUUID]);
                                    bufferBtAction(getCharacteristic, [service, settingsRespUUID]);
                                    bufferBtAction(getCharacteristic, [service, queryUUID]);
                                    bufferBtAction(getCharacteristic, [service, queryRespUUID]);
                                    break;
                                case defInfoUUID:
                                    console.log('Got defInfo Service');
                                    console.log('Getting model_number_string Characteristic...');
                                    bufferBtAction(getCharacteristic, [service, modelNoUUID]);
                                    break;
                                case wifiServiceUUID:
                                    console.log('Got wifi Service');
                                    console.log('Getting wifi Characteristics...');
                                    bufferBtAction(getCharacteristic, [service, wifiSsidUUID]);
                                    bufferBtAction(getCharacteristic, [service, wifiPwUUID]);
                                    bufferBtAction(getCharacteristic, [service, wifiStateUUID]);
                                    break;
                                case nwManServiceUUID:
                                    console.log('Got nwMan Service');
                                    console.log('Getting nwMan Characteristics...');
                                    bufferBtAction(getCharacteristic, [service, nwManCmdUUID]);
                                    bufferBtAction(getCharacteristic, [service, nwManRespUUID]);
                                    break;
                            }
                        }

                        break;
                    }
                }
            })
            .catch(error => {
                showInfo("[onClickPair] " + error, 0);
                logError("[onClickPair] " + error);
                resetConnectingDev();
            });
    }

    function getCharacteristic(args) {
        var service = args[0],
            uuid = args[1];

        service.getCharacteristic(uuid)
            .then(characteristic => {
                bufferExecNext();
                if (characteristic == null) {
                    logError("[getCharacteristic] Characteristic is 'null'");
                    return;
                }
                console.log('Got Characteristic');

                // Save characteristic in connectedDevs[i]
                for (var i = 0; i < connectedDevs.length; i++) {
                    if (connectedDevs[i].server.device.id == characteristic.service.device.id) {
                        var dev = connectedDevs[i];

                        switch (characteristic.uuid) {
                            case commandUUID:
                                dev.commandCharacteristic = characteristic;
                                if (dev.commandRespCharacteristic != null) {
                                    bufferBtAction(sendCommandToSingle, [getHardwareInfo, i]);
                                }
                                break;
                            case commandRespUUID:
                                dev.commandRespCharacteristic = characteristic;
                                startNotifications(dev.commandRespCharacteristic);
                                if (dev.commandCharacteristic != null) {
                                    bufferBtAction(sendCommandToSingle, [getHardwareInfo, i]);
                                }
                                break;
                            case settingsUUID:
                                dev.settingsCharacteristic = characteristic;
                                return;
                            case settingsRespUUID:
                                dev.settingsRespCharacteristic = characteristic;
                                startNotifications(dev.settingsRespCharacteristic);
                                return;
                            case queryUUID:
                                dev.queryCharacteristic = characteristic;
                                if (dev.queryRespCharacteristic != null) {
                                    bufferBtAction(sendQueryToSingle, [queryAllStatusValues, i]);
                                    bufferBtAction(sendQueryToSingle, [registerForAllStatusValueUpdates, i]);
                                }
                                break;
                            case queryRespUUID:
                                dev.queryRespCharacteristic = characteristic;
                                startNotifications(dev.queryRespCharacteristic);
                                if (dev.queryCharacteristic != null) {
                                    bufferBtAction(sendQueryToSingle, [queryAllStatusValues, i]);
                                    bufferBtAction(sendQueryToSingle, [registerForAllStatusValueUpdates, i]);
                                }
                                break;
                            case modelNoUUID:
                                dev.modelNoCharacteristic = characteristic;
                                if (dev.ModelID <= 0)
                                    bufferBtAction(readValue, [dev.modelNoCharacteristic]);
                                return;
                            case wifiSsidUUID:
                                dev.wifiSsidCharacteristic = characteristic;
                                bufferBtAction(readValue, [dev.wifiSsidCharacteristic]);
                                return;
                            case wifiPwUUID:
                                dev.wifiPwCharacteristic = characteristic;
                                bufferBtAction(readValue, [dev.wifiPwCharacteristic]);
                                return;
                            case wifiStateUUID:
                                dev.wifiStateCharacteristic = characteristic;
                                bufferBtAction(readValue, [dev.wifiStateCharacteristic]);
                                return;
                            case nwManCmdUUID:
                                // TODO implement
                                dev.nwManCmdCharacteristic = characteristic;
                                return;
                            case nwManRespUUID:
                                // unused
                                dev.nwManRespCharacteristic = characteristic;
                                return;
                        }
                    }
                }
            })
            .catch(error => {
                bufferExecNext();
                console.log(new Date().toLocaleString() + ' [getCharacteristic] ERROR! ' + error);
                logError("[getCharacteristic] " + error);
                if (connectingDev != null) {
                    showInfo("Connecting '" + connectingDev.name + "' error: '" + error + "'. Please retry!", 5000);
                    resetConnectingDev();
                }
            });
    }

    function startNotifications(characteristic) {
        characteristic.startNotifications()
            .then(_ => {
                console.log('> Characteristic Notifications started');
                characteristic.addEventListener('characteristicvaluechanged', parseBtData);
            })
            .catch(error => {
                if (error.message.includes("Authentication failed")) {
                    removeConnectedDev(characteristic.service.device);
                    resetConnectingDev();

                    showInfo("Authentication failed! Perform Bluetooth pairing first! See Error Log for details!");
                    logError("[startNotifications] " + error);
                    logError("Authentication failed!<br>Please first perform a Bluetooth pairing with the camera via your device Bluetooth manager!");
                    document.getElementById("errorLog").classList.add('expanded');
                }
            });
    }

    function removeConnectedDev(dev) {
        if (dev === null)
            return;

        for (var i = 0; i < connectedDevs.length; i++) {
            if (connectedDevs[i].server.device.id == dev.gatt.device.id) {
                connectedDevs[i].server.device.removeEventListener('gattserverdisconnected', onDisconnected);
                connectedDevs[i].server.device.gatt.disconnect();
                connectedDevs.splice(i, 1);
                dev = null;
                updateList();
                break;
            }
        }
    }

    function resetConnectingDev() {
        if (connectingDev === null)
            return;

        connectingDev.gatt.disconnect();
        updateList();
        connectingDev = null;
    }

    /*
    *   Non-blocking asynchronous execution of the BLE communication functions
    */
    function bufferBtAction(action, ...args) {
        btActionBuffer.push([action, args]);
    }

    function bufferExecNext() {
        var lastExecMillis = new Date() - execMillis;
        (function chunk() {
            if (btActionBuffer.length < 1) {
                setTimeout(chunk, 0);
            } else {
                if (btActionBuffer.length >= 20)
                    logError("[bufferExecNext] There is too much in the btActionBuffer! (" + btActionBuffer.length + ")");
                execMillis = new Date();
                var btAction = btActionBuffer.pop();
                btAction[0](...btAction[1]); //TODO! Hardcoded number of arguments! How can this be done better?
            }
        })();
    }

    /*
    *   Active BLE communication
    */
    function readValue(args) { //maximum execution time measured is 122 ms
        var characteristic = args[0];

        if (characteristic == null) {
            logError("[readValue] Characteristic is 'null'");
            bufferExecNext();
            return;
        }
        console.log(new Date().toLocaleString() + ' [readValue] ' + characteristic.uuid);
        characteristic.readValue()
            .then(value => {
                bufferExecNext();
                for (var i = 0; i < connectedDevs.length; i++) {
                    if (connectedDevs[i].server.device.id == characteristic.service.device.id) {
                        let decoder = new TextDecoder('utf-8');
                        let value_str = decoder.decode(value);

                        switch (characteristic.uuid) {
                            case modelNoUUID:
                                var modelInt = parseInt("0x" + value_str);
                                if (isNaN(modelInt))
                                    return;

                                connectedDevs[i].ModelID = modelInt;

                                var model_name = gopro_models[connectedDevs[i].ModelID];
                                if (model_name != null)
                                    connectedDevs[i].Model = model_name;
                                else {
                                    connectedDevs[i].Model = connectedDevs[i].ModelID;
                                    alert("Your GoPro model is unknown.\nPlease tell the autor your camera model and the model ID: " + connectedDevs[i].ModelID);
                                }

                                console.log('> Model is ' + connectedDevs[i].Model);
                                updateList();
                                return;
                            case wifiSsidUUID:
                                connectedDevs[i].WifiSsid = value_str;
                                return;
                            case wifiPwUUID:
                                connectedDevs[i].WifiPw = value_str;
                                return;
                            case wifiStateUUID:
                                connectedDevs[i].WifiState = value_str;
                                return;
                        }
                    }
                }
            })
            .catch(error => {
                console.log(new Date().toLocaleString() + ' [readValue] ERROR! ' + error);
                logError("[readValue] " + error);
                bufferExecNext();
            });
    }

    function sendCommand(command) {
        for (var i = 0; i < connectedDevs.length; i++) {
            bufferBtAction(sendCommandToSingle, [command, i]);
        }
    }

    function sendCommandToSingle(args) {
        const data = args[0],
            camIndex = args[1];
        const characteristic = connectedDevs[camIndex].commandCharacteristic;

        if (characteristic != null && connectedDevs[camIndex].server != null && connectedDevs[camIndex].server.connected)
            sendToSingle(data, characteristic);
    }

    function sendSettingToSingle(args) {
        const data = args[0],
            camIndex = args[1];
        const characteristic = connectedDevs[camIndex].settingsCharacteristic;

        if (characteristic != null && connectedDevs[camIndex].server != null && connectedDevs[camIndex].server.connected)
            sendToSingle(data, characteristic);
    }

    function sendQueryToSingle(args) {
        const data = args[0],
            camIndex = args[1];
        const characteristic = connectedDevs[camIndex].queryCharacteristic;

        if (characteristic != null && connectedDevs[camIndex].server != null && connectedDevs[camIndex].server.connected)
            sendToSingle(data, characteristic);
    }

    // TODO currently unused -> Use this option (for example) to send "bt pair completed" command ({0x0f, 0x03, 0x01, 0x08, 0x00, 0x12, 0x09, 'G', 'o', 'E', 'a', 's', 'y', 'P', 'r', 'o'})
    function sendNwToSingle(args) {
        const data = args[0],
            camIndex = args[1];
        const characteristic = connectedDevs[camIndex].nwManCmdCharacteristic;

        if (characteristic != null && connectedDevs[camIndex].server != null && connectedDevs[camIndex].server.connected)
            sendToSingle(data, characteristic);
    }

    // TODO currently unused -> Use this option to change the WiFi AP SSID name (device name) -> then the change must be confirmed with the WiFi AP password
    function sendWifiSsidToSingle(args) {
        const data = args[0],
            camIndex = args[1];
        const characteristic = connectedDevs[camIndex].wifiSsidCharacteristic;

        if (characteristic != null && connectedDevs[camIndex].server != null && connectedDevs[camIndex].server.connected)
            sendToSingle(data, characteristic);
    }
    
    // TODO currently unused -> Use this option to set the WiFi AP password or confirm the WiFi AP SSID name change
    function sendWifiPwToSingle(args) {
        const data = args[0],
            camIndex = args[1];
        const characteristic = connectedDevs[camIndex].wifiPwCharacteristic;

        if (characteristic != null && connectedDevs[camIndex].server != null && connectedDevs[camIndex].server.connected)
            sendToSingle(data, characteristic);
    }

    function sendToSingle(data, characteristic) {
        // split data into chunks if len > MTU
        const dataLen = data.length;
        const chunkLen = Math.min(dataLen, MTU);
        const payload = new ByteBuffer(chunkLen);
        payload.put(data, 0, chunkLen);

        if (dataLen > MTU) {
            var remain = dataLen - chunkLen;
            const nextPayload = new ByteBuffer(remain)
            nextPayload.put(data, chunkLen, remain);
            bufferBtAction(sendToSingle, [nextPayload, characteristic]);
        }

        console.log(new Date().toLocaleString() + ' [sendToSingle] ' + payload);

        characteristic.writeValueWithoutResponse(payload)
            .then(_ => {
                bufferExecNext();
            })
            .catch(error => {
                console.log(new Date().toLocaleString() + ' [sendToSingle] ERROR! ' + error);
                logError("[sendToSingle] " + error);
                bufferExecNext();
            });
    }

    function setDateTime(camIndex) {
        var now = new Date();
        let yyH = now.getFullYear();
        let yyL = (now.getFullYear() >> 8);
        // Set date/time to 2022-01-02 03:04:05 	Command: 09: 0D: 07: 07:E6: 01: 02: 03: 04: 05
        var command = Uint8Array.from([0x09, 0x0d, 0x07, yyL, yyH, (now.getMonth() + 1), now.getDate(), now.getHours(), now.getMinutes(), now.getSeconds()]);
        bufferBtAction(sendCommandToSingle, [command, camIndex]);
    }

    function intervalActions() {
        if (connectingDev == null)
            for (var i = 0; i < connectedDevs.length; i++) {
                if (!connectedDevs[i].server.connected)
                    continue;

                var now = new Date();

                // Send "keep alive" every 3 seconds; only for models newer then hero 8
                if (now - connectedDevs[i].lastKeepAlive > 3000) {
                    if (connectedDevs[i].ModelID > 50) {
                        bufferBtAction(sendSettingToSingle, [keepAlive, i]);
                        connectedDevs[i].lastKeepAlive = now;
                    }

                    if (connectedDevs[i].Model === "?") {
                        bufferBtAction(sendCommandToSingle, [getHardwareInfo, i]);
                    }
                }

                // Query "Remaining space"
                if (!connectedDevs[i].autoValueUpdatesRegistered && now - connectedDevs[i].lastMemoryQuery > 7000) {
                    bufferBtAction(sendQueryToSingle, [qSpace, i]);
                    connectedDevs[i].lastMemoryQuery = now;
                }

                // Query "Active preset"
                if (!connectedDevs[i].autoValueUpdatesRegistered && now - connectedDevs[i].lastPresetQuery > 2000) {
                    if (connectedDevs[i].ModelID > 21) { // qPreset query not supported from Hero 5 Black
                        bufferBtAction(sendQueryToSingle, [qPreset, i]);
                    }
                    connectedDevs[i].lastPresetQuery = now;
                }

                // Read "Battery level"
                if (!connectedDevs[i].autoValueUpdatesRegistered && now - connectedDevs[i].lastBatteryRead > 10000) {
                    bufferBtAction(readValue, [connectedDevs[i].battLevelCharacteristic]);
                    connectedDevs[i].lastBatteryRead = now;
                }
            }
    }

    let packBuffer = null;
    let lastPackNo = -1;

    function parseBtData(event) {
        let value = event.target.value;
        let uuid = event.target.uuid;
        let sender_id = event.target.service.device.id;
        let bytes = [];

        for (let i = 0; i < value.byteLength; i++) {
            bytes.push(value.getUint8(i));
        }
        let valueBytes = Uint8Array.from(bytes);

        const isContPack = (valueBytes[0] & 128) > 0;
        const currPackNo = valueBytes[0];

        if (isContPack) {
            if ((lastPackNo === -1 && currPackNo === 128) || (lastPackNo === 143 && currPackNo === 128) || (lastPackNo + 1 === currPackNo)) {
                lastPackNo = currPackNo;

                const dataLen = valueBytes.length - 1;

                if (packBuffer !== null) {
                    try {
                        const putLen = Math.min(packBuffer.remaining(), dataLen);
                        if (putLen !== dataLen) {
                            console.error("parseBtData: Received data length is " + (dataLen - putLen) + " larger than the buffer");
                        }
                        packBuffer.put(valueBytes.subarray(1, 1 + putLen));
                    } catch (e) {
                        console.error("parseBtData: Error: " + e);
                        bufferExecNext();
                        return;
                    }

                    if (packBuffer.remaining() <= 0) {
                        // all data received
                        parseBtResponsePack(packBuffer, uuid, sender_id);
                        bufferExecNext();
                    }
                } else {
                    console.error("parseBtData: Cont pack buffer was null");
                    bufferExecNext();
                }
            } else if (packBuffer !== null) {
                console.error("parseBtData: Invalid ContPack pack number received! lastPackNo: " + lastPackNo + ", currPackNo: " + currPackNo + " for commandId: " + lastCommandId);
                packBuffer = null;
            }
        } else {
            const header = new GoHeader(valueBytes);

            const headerLength = header.getHeaderLength();
            const msgLen = header.getMsgLength();
            const commandId = valueBytes[headerLength];
            const error = valueBytes[headerLength + 1];
            const dataLen = valueBytes.length - headerLength;

            if (packBuffer !== null && packBuffer.remaining() > 0) {
                // handle unhandled data
                console.error(`parseBtData: New Response with command ID 0x${commandId.toString(16).toUpperCase()} received while awaiting contPack data!`);
            }

            packBuffer = new ByteBuffer(msgLen);
            const putLen = Math.min(packBuffer.remaining(), dataLen);
            if (putLen !== dataLen) {
                console.error("parseBtData: Received data length is " + (dataLen - putLen) + " larger than the buffer");
            }
            packBuffer.put(valueBytes.subarray(headerLength, headerLength + putLen));

            lastCommandId = commandId;
            lastPackNo = -1;
            // console.error("GOPRO RESPONSE", "parseBtData() msgLen: " + msgLen + ", dataLen: " + dataLen + ", commandId: " + commandId + ", error: " + error + ", packBuffer.remaining: " + packBuffer.remaining());

            if (packBuffer.remaining() <= 0) {
                // all data received
                parseBtResponsePack(packBuffer, uuid, sender_id);
                bufferExecNext();
            }
        }
    }

    function isProtobuf(response) {
        if (response.length > 2) {
            const msgFeatureID = response[0];
            const msgActionID = response[1];

            for (let i1 = 0; i1 < featureIDs.length; i1++) {
                const currentFeatureID = featureIDs[i1];
                const currentActionIDs = actionIDs[i1];

                if (msgFeatureID === currentFeatureID) {
                    for (let j = 0; j < currentActionIDs.length; j++) {
                        const currentActionID = currentActionIDs[j];
                        if (msgActionID === currentActionID) {
                            return true;
                        }
                    }
                }
            }
        }

        return false;
    }

    function parseBtResponsePack(responsePack, uuid, sender_id) {
        if (isProtobuf(responsePack)) {
            // currently not implemented
            console.error("parseBtResponsePack: Protobuf data received! Parsing not implemented!");
            return;
        }

        var commandId = responsePack[0];
        var error = responsePack[1];
        var nextStart = 2;

        if (error === 0) {
            var byteBuffer;

            for (var i = 0; i < connectedDevs.length; i++) {
                if (connectedDevs[i].server.device.id == sender_id) {
                    let uint8bytes = Uint8Array.from(responsePack);
                    let byteArray = new DataView(uint8bytes.buffer);

                    switch (commandId) {
                        case 60:
                            // Hardware info -> Model ID, model name, board type, firmware version, serial number, AP SSID, AP MAC Address
                            let decoder = new TextDecoder('utf-8');
                            var nextLen = responsePack[nextStart++];

                            // Model ID
                            connectedDevs[i].ModelID = byteArray.getUint32(nextStart);

                            nextStart = nextStart + nextLen;
                            nextLen = responsePack[nextStart++];

                            // model name
                            var nameBytes = uint8bytes.subarray(nextStart, nextStart + nextLen);
                            connectedDevs[i].Model = decoder.decode(nameBytes);

                            nextStart = nextStart + nextLen;
                            nextLen = responsePack[nextStart++];

                            /* 
                                // board type
                                byteBuffer = new ByteBuffer(nextLen);
                                byteBuffer.putSubarray(byteArray, nextStart, nextLen);
                                boardType = new String(byteBuffer.array(), StandardCharsets.UTF_8).trim();
        
                                nextStart = nextStart + nextLen;
                                nextLen = responsePack[nextStart++];
        
                                // firmware
                                byteBuffer = new ByteBuffer(nextLen);
                                byteBuffer.putSubarray(byteArray, nextStart, nextLen);
                                fwVersion = new String(byteBuffer.array(), StandardCharsets.UTF_8).trim();
        
                                nextStart = nextStart + nextLen;
                                nextLen = responsePack[nextStart++];
        
                                // serial number
                                byteBuffer = new ByteBuffer(nextLen);
                                byteBuffer.putSubarray(byteArray, nextStart, nextLen);
                                serialNumber = new String(byteBuffer.array(), StandardCharsets.UTF_8).trim();
        
                                nextStart = nextStart + nextLen;
                                nextLen = responsePack[nextStart++];
        
                                // AP SSID
                                byteBuffer = new ByteBuffer(nextLen);
                                byteBuffer.putSubarray(byteArray, nextStart, nextLen);
                                wifiSSID = new String(byteBuffer.array(), StandardCharsets.UTF_8).trim();
                                saveNewDisplayName(wifiSSID);
        
                                nextStart = nextStart + nextLen;
                                nextLen = responsePack[nextStart++];
        
                                // AP MAC Address
                                byteBuffer = new ByteBuffer(nextLen);
                                byteBuffer.putSubarray(byteArray, nextStart, nextLen);
                                StringBuilder sb = new StringBuilder(new String(byteBuffer.array(), StandardCharsets.UTF_8).trim());
                                sb.insert(2, ':');
                                sb.insert(5, ':');
                                sb.insert(8, ':');
                                sb.insert(11, ':');
                                sb.insert(14, ':');
                                wifiBSSID = sb.toString().toUpperCase();
                            */

                            break;
                        case 147: // Why does Hero12 send 147 instead of 19?
                        case 83:
                            connectedDevs[i].autoValueUpdatesRegistered = true;
                        case 19:
                            // Status values
                            for (var index = nextStart; index < uint8bytes.byteLength;) {
                                var statusID = uint8bytes[index];
                                if (uint8bytes.byteLength > index + 1) nextLen = uint8bytes[index + 1];
                                else break;

                                if (nextLen > 0) {
                                    byteBuffer = new ByteBuffer(nextLen);
                                    byteBuffer.putSubarray(uint8bytes, index + 2, nextLen);
                                    handleStatusData(statusID, byteBuffer, connectedDevs[i]);
                                }

                                index += nextLen + 2;
                            }
                            break;
                        /* 
                            case 162:
                            case 50:
                                // Available option IDs for all settings
                                availableSettingsOptions = new ArrayList <> ();

                                for (var index = nextStart; index < byteArray.length; ) {
                                var settingId = byteArray[index];
                                    if (byteArray.length > index + 1) nextLen = byteArray[index + 1];
                                    else break;

                                    if (nextLen > 0) {
                                    var optionId = byteArray[index + 2];

                                        availableSettingsOptions.add(new Pair <> (settingId, optionId));
                                    }

                                    index += nextLen + 2;
                                }

                                getAllSettings();
                                break;
                            case 146:
                            case 18:
                                // All settings
                                goSettings = new ArrayList <> ();

                                for (var index = nextStart; index < byteArray.length; ) {
                                var settingID = byteArray[index];
                                    if (byteArray.length > index + 1) {
                                        nextLen = byteArray[index + 1];
                                        if (byteArray.length < index + 2 + nextLen) {
                                            //nextLen = byteArray.length - index - 2;
                                            break;
                                        }
                                    } else {
                                        break;
                                    }

                                    if (nextLen > 0) {
                                        byteBuffer = new ByteBuffer(nextLen);
                                        byteBuffer.putSubarray(byteArray, index + 2, nextLen);
                                        handleSettingData(settingID, byteBuffer);
                                    }

                                    index += nextLen + 2;
                                }

                                goSettings.sort(Comparator.comparing(GoSetting:: getGroupName));
                                goSettings.sort(Comparator.comparingInt(GoSetting:: getSettingId));

                                if (settingsChangedCallback != null)
                                    settingsChangedCallback.onSettingsChanged();
                                break;
                            case 59:
                                // Settings JSON gzip
                                byteBuffer = new ByteBuffer(byteArray.length - 2);
                                byteBuffer.putSubarray(byteArray, 2, byteArray.length - 2);
                                byteBuffer.flip();

                                String json_str = decompress(byteBuffer.array());
                                Log.e("JSON", json_str);
                                break; 
                        */
                    }

                    /* 
                        switch (uuid) {
                            case commandRespUUID:
    
                                if (commandId != 0x3C)
                                    break; // is not Hardware Info
    
                                
    
                                break;
                            case settingsRespUUID:
                                // do nothing with keep alive response
                                break;
                            case queryRespUUID:
                                var queryCode = responsePack[3];
                                var dataLen = responsePack[4];
                                if (queryCode == 0x36 && dataLen == 8) { // Remaining space
                                    let bytes = [responsePack[5], responsePack[6], responsePack[7], responsePack[8], responsePack[9], responsePack[10], responsePack[11], responsePack[12]];
                                    let uint8bytes = Uint8Array.from(bytes);
                                    let dataview = new DataView(uint8bytes.buffer);
                                    let int64be = dataview.getBigUint64(0);
    
                                    connectedDevs[i].Memory = parseFloat(parseFloat(int64be / 1024n) / 1024.00).toFixed(2) + " GB";
                                } else if (queryCode == 0x61 && dataLen == 4) { // Active preset
                                    let bytes = [responsePack[5], responsePack[6], responsePack[7], responsePack[8]];
                                    let uint8bytes = Uint8Array.from(bytes);
                                    let dataview = new DataView(uint8bytes.buffer);
                                    let int32be = dataview.getUint32(0);
    
                                    if (presets[int32be] != null)
                                        connectedDevs[i].Preset = presets[int32be];
                                    else
                                        connectedDevs[i].Preset = "unknown";
                                }
                                break;
                        } 
                    */
                }
            }

            packBuffer = null;
            updateList();
        } else {
            // TODO log
        }
    }

    function handleStatusData(statusID, buffer, dev) {
        const byteBuffer = new ByteBuffer(buffer.byteLength);
        byteBuffer.put(buffer);
        const dataview = new DataView(byteBuffer.buffer);

        switch (statusID) {
            case 2:
                dev.isCharging = buffer[0] === 4;
                break;
            case 6:
                dev.isHot = buffer[0] !== 0;
                break;
            case 85:
                dev.isCold = buffer[0] !== 0;
                break;
            case 8:
                dev.isBusy = buffer[0] !== 0;
                break;
            case 13:
                /* lastVideoProgressReceived = new Date(); */
                dev.videoProgress = dataview.getUint32(0);

                /* let wasRecording = dev.isRecording; */
                dev.isRecording = dev.videoProgress !== 0;
                /* if (dev.isRecording && !wasRecording) {
                    ShutterLog.logShutter(_context, displayName, "started");
                    initShutterWatchdog();
                } else if (!dev.isRecording && wasRecording) {
                    ShutterLog.logShutter(_context, displayName, "stopped");
                } */
                break;
            case 43:
            case 89:
                /* let modeId = buffer[0];
                mode = new GoMode(_context, modeId); */
                break;
            case 54:
                // Remaining space                
                var int64be = dataview.getBigUint64(0);
                dev.Memory = parseFloat(parseFloat(int64be / 1024n) / 1024.00).toFixed(2) + " GB";
                break;
            case 69:
                // wifiApState = buffer[0];
                break;
            case 70:
                dev.Battery = buffer[0];
                break;
            case 97:
                // Active preset
                var int32be = dataview.getUint32(0)

                if (presets[int32be] != null)
                    dev.Preset = presets[int32be];
                else
                    dev.Preset = "unknown";
                break;
            case 114:
                /* let ccStatus = buffer[0];
                if (ccStatus === 0) {
                    getCurrentPreset();
                } */
                break;
            /*default:
                console.error("handleStatusData: unhandled statusID " + statusID.toString(16) + " received");*/
        }
    }

    function onDisconnected(event) {
        let sender_id = event.target.id;

        for (var i = 0; i < connectedDevs.length; i++) {
            if (connectedDevs[i].server.device.id == sender_id) {
                showInfo("Cam '" + connectedDevs[i].server.device.name + "' disconnected.", 5000);
                connectedDevs[i].server.device.removeEventListener('gattserverdisconnected', onDisconnected);
                connectedDevs.splice(i, 1);
                updateList();
                break;
            }
        }
        // Close menu
        PopupMenu.removeMenu();
    }

    /*
    *   Helpers
    */
    function showInfo(text, millis) {
        document.getElementById("status").innerHTML = text;
        if (millis > 0)
            window.setTimeout(function () {
                document.getElementById("status").innerText = "";
            }, millis);
    }

    function logError(msg) {
        var errTabBody = document.getElementById("error_log_table").tBodies[0];
        var newRow = errTabBody.insertRow();
        newRow.innerHTML = '<td class="cam-td" style="text-align: center;">' + new Date().toLocaleString() + '</td><td style="text-align: left;padding-left: 10px;">' + msg + '</td>';
    }

    function updateList() {
        var tBody = document.createElement("tbody");
        for (var i = 0; i < connectedDevs.length; i++) {
            const camRow = document.createElement("tr");

            const camInfoTD = document.createElement("td");
            camInfoTD.className = "cam-td";
            camInfoTD.innerHTML = '' +
                '<div><span><b>Name: </b>' + connectedDevs[i].Name + '</span> <span><b>Model: </b>' + connectedDevs[i].Model + '</span></div>' +
                '<div><span><b>Preset: </b>' + connectedDevs[i].Preset + '</span> <span><b>Video progress: </b><span' + (connectedDevs[i].isRecording ? ' style="margin:0;color:red;"' : ' style="margin:0;"') + '>' + secondsToTimeStr(connectedDevs[i].videoProgress) + (connectedDevs[i].isRecording ? ' (recording)' : ' (stopped)') + '</span></span> <span><b>Busy: </b>' + connectedDevs[i].isBusy + '</span></div>' +
                '<div><span' + (connectedDevs[i].Battery <= 15 && !connectedDevs[i].isCharging ? ' style="color:red;"' : '') + '><b>Battery: </b>' + connectedDevs[i].Battery + ' %' + (connectedDevs[i].isCharging ? ' (charging)' : '') + '</span> <span><b>Memory: </b>' + connectedDevs[i].Memory + '</span> <span' + (connectedDevs[i].isHot ? ' style="color:red;"' : '') + '><b>Hot: </b>' + connectedDevs[i].isHot + '</span> <span' + (connectedDevs[i].isCold ? ' style="color:red;"' : '') + '><b>Cold: </b>' + connectedDevs[i].isCold + '</span></div>'

            // menu td
            const menuTD = document.createElement("td");

            // menu button
            const menuButton = document.createElement("input");
            menuButton.type = "button";
            menuButton.className = "list-btn";
            menuButton.value = '';
            menuButton.id = i;
            const menu = new PopupMenu(menuButton, ["click"], cam_menu_items);

            menuTD.appendChild(menuButton);
            camRow.appendChild(camInfoTD)
            camRow.appendChild(menuTD)
            tBody.appendChild(camRow);
        };
        dev_list.removeChild(dev_list.children[1]);
        dev_list.appendChild(tBody);
    }

    function delay(millis) {
        var s = new Date();
        while (new Date() - s < millis);
    }

    function getBit(num, bit) {
        return ((num >> bit) % 2 != 0 ? 1 : 0)
    }

    function getSvgUrl(svg_str) {
        return 'data:image/svg+xml,' + encodeURIComponent(svg_str) + '';
    }

    function secondsToTimeStr(seconds) {
        var hours = Math.floor(seconds / 3600);
        var minutes = Math.floor((seconds % 3600) / 60);
        var secondsRemain = seconds % 60;

        minutes = minutes < 10 ? '0' + minutes : minutes;
        secondsRemain = secondsRemain < 10 ? '0' + secondsRemain : secondsRemain;

        return (hours > 0 ? (hours + ':') : '') + minutes + ':' + secondsRemain;
    }

    class GoHeader {
        constructor(payload) {
            const byte0 = payload[0];
            const byte1 = payload[1];
            const byte2 = payload[2];

            if ((byte0 & 32) > 0) {
                this.headerLength = 2;
                this.msgLength = ((byte0 & 0x0f) << 8) | byte1;
            } else if ((byte0 & 64) > 0) {
                this.headerLength = 3;
                this.msgLength = (byte1 << 8) | byte2;
            } else if ((byte0 & 128) > 0) {
                this.headerLength = 1;
                this.msgLength = -1;
            } else {
                this.headerLength = 1;
                this.msgLength = byte0;
            }

            this.headerBytes = new Uint8Array(payload.slice(0, this.headerLength));
        }

        getHeaderLength() {
            return this.headerLength;
        }

        getMsgLength() {
            return this.msgLength;
        }

        toString() {
            let stringBuilder = "[GoHeader]\n";
            stringBuilder += `\tHeader length: ${this.headerLength}\n`;
            stringBuilder += "\tHeader bytes: ";
            for (let i = 0; i < this.headerLength; i++) {
                stringBuilder += `0x${this.headerBytes[i].toString(16).toUpperCase()}`;
                if (i < this.headerLength - 1) stringBuilder += ", ";
                else stringBuilder += "\n";
            }
            stringBuilder += `\tPayload length: ${this.msgLength}`;

            return stringBuilder;
        }
    }

    class ByteBuffer extends Uint8Array {
        constructor(len) {
            super(len);
            this.position = 0;
        }

        put(array) {
            this.set(array, this.position);
            this.position += array.length;
        }

        putSubarray(array, begin, length) {
            if (begin === undefined) {
                this.put(array);
                return
            }

            this.set(array.subarray(begin, begin + length), this.position);
            this.position += array.length;
        }

        remaining() {
            return this.length - this.position;
        }
    }
</script>

<script>
    // light mode
    const color = "#3b3b3b";
    const color_highlight = "#000";
    const bg_color = "#fff";
    const bg_color_highlight = "#e8e8e8";
    const border_color = "#cecece";
    // dark mode
    const color_dark = "#ccc";
    const color_highlight_dark = "#fff";
    const bg_color_dark = "#1f1f1f";
    const bg_color_highlight_dark = "#04395e";
    const border_color_dark = "#454545";

    class PopupMenu {
        constructor(sender, eventTypes, menuItems) {
            this.sender = sender;
            this.eventTypes = eventTypes;
            this.menuItems = menuItems;

            for (var i = 0; i < this.eventTypes.length; i++) {
                const eventType = eventTypes[i];
                const popupMenu = this;
                this.sender.addEventListener(eventType, function (event) {
                    event.preventDefault();
                    event.stopPropagation();

                    PopupMenu.removeMenu();

                    const _x = event.clientX;
                    const _y = event.clientY;

                    const cm = PopupMenu.createMenu(_x, _y, popupMenu.sender, popupMenu.menuItems, isDarkMode());
                    document.body.appendChild(cm);

                    PopupMenu.checkPosWithinScreen(cm);
                });
            }
        }

        addItems(menuItems) {
            if (Array.isArray(menuItems))
                this.menuItems.push(...menuItems);
            else
                this.menuItems.push(menuItems);
        }

        // Outer DIV
        static createMenu(x, y, sender, items, darkmode) {
            const cm = document.createElement("div");
            cm.setAttribute("name", "PopupMenu");

            document.addEventListener("click", PopupMenu.removeMenu);

            cm.setAttribute("style", 'display: block; min-width: 150px; position: absolute; box-sizing: border-box; outline: 0px; z-index: 2002;box-shadow: 0 0 7px rgba(50,50,50,.4);border: 1px solid; border-radius: 5px; font-size: 12px;cursor: default;padding: 4px; white-space: nowrap; overflow-x: visible; max-height: 561px; overflow-y: visible;text-align: left;')

            cm.style.left = x + "px";
            cm.style.top = y + "px";
            cm.style.backgroundColor = darkmode ? bg_color_dark : bg_color;
            cm.style.borderColor = darkmode ? border_color_dark : border_color;
            cm.dataset.sender_id = sender.id;

            const menu_div = PopupMenu.createMenuDiv(items, darkmode, sender);

            cm.appendChild(menu_div);

            return cm;
        }

        // Item holder DIV
        static createMenuDiv(items, darkmode, sender) {
            const menu_div = document.createElement("div");
            menu_div.role = "menu";
            menu_div.style.outline = 0;

            for (var i = 0; i < items.length; i++) {
                var item = items[i];

                const menu_item = PopupMenu.createMenuItemDiv(item, darkmode);

                // Sub-Items
                if (item.items && item.items.length > 0) {
                    menu_item.style.background = 'transparent no-repeat right';
                    var svg_str = "<svg xmlns='http://www.w3.org/2000/svg' width='50px' height='50px' viewBox='0 0 256 256'><g fill='" + (darkmode ? color_dark : color) + "'><g transform='scale(5.12,5.12)'><path d='M16,5v42l22,-21z'></path></g></g></svg>"
                    var svg_url = 'url("data:image/svg+xml,' + encodeURIComponent(svg_str) + '")';
                    menu_item.style.backgroundImage = svg_url;
                    menu_item.style.backgroundPosition = 'right 6px top 9px';
                    menu_item.style.backgroundSize = '12px';

                    menu_item.dataset.subMenuShown = "false";

                    const _subItems = item.items;

                    menu_item.addEventListener("mouseover", function (ev) {
                        const cm = PopupMenu.createMenu(menu_item.offsetWidth, menu_item.offsetTop, sender, _subItems, darkmode);
                        if (menu_item.dataset.subMenuShown === "false") {
                            menu_item.dataset.subMenuShown = "true";
                            menu_item.appendChild(cm);
                            PopupMenu.checkPosWithinScreen(cm);
                        }
                    });

                    menu_item.addEventListener("mouseleave", function (ev) {
                        if (menu_item.dataset.subMenuShown === "true") {
                            for (let i = menu_item.childNodes.length - 1; i >= 0; i--) {
                                if (menu_item.childNodes[i].nodeName === 'DIV') {
                                    menu_item.removeChild(menu_item.childNodes[i]);
                                    menu_item.dataset.subMenuShown = "false";
                                    return;
                                }
                            }
                        }
                    });
                }

                menu_div.appendChild(menu_item);
            }

            return menu_div;
        }

        // Menu item DIV
        static createMenuItemDiv(item, darkmode) {
            // Item outer DIV
            const menu_item = document.createElement("div");
            menu_item.role = "menuitem";

            menu_item.style.display = "block";
            menu_item.style.cursor = "pointer";
            menu_item.style.borderRadius = "3px";
            menu_item.style.backgroundColor = (darkmode ? bg_color_dark : bg_color);
            menu_item.style.color = (item.color ? item.color : (darkmode ? color_dark : color));
            menu_item.style.padding = "6px";

            switch (item.type) {
                case "title":
                    menu_item.style.userSelect = "none";
                    menu_item.style.backgroundColor = (darkmode ? border_color_dark : border_color);
                    menu_item.style.marginBottom = "6px";
                    menu_item.style.lineHeight = "0.9";
                    break;
                default:
                    menu_item.setAttribute("onmouseover", 'this.style.backgroundColor = "' + (darkmode ? bg_color_highlight_dark : bg_color_highlight) + '"; this.style.color = "' + (item.color ? item.color : (darkmode ? color_highlight_dark : color_highlight)) + '";');
                    menu_item.setAttribute("onmouseout", 'this.style.backgroundColor = "' + (item.backgroundColor ? item.backgroundColor : (darkmode ? bg_color_dark : bg_color)) + '"; this.style.color = "' + (item.color ? item.color : (darkmode ? color_dark : color)) + '";');

            }

            if (item.onclick) {
                menu_item.addEventListener("click", item.onclick);
            }

            // Icon
            if (item.icon && item.icon.type && item.icon.src) {
                switch (item.icon.type) {
                    case "url":
                        const icon = document.createElement("span");
                        icon.style.display = "inline-block";
                        icon.style.verticalAlign = "middle";
                        icon.style.width = "18px";
                        icon.style.height = "18px";

                        if (item.icon.src_dark && darkmode) {
                            icon.style.background = "url('" + item.icon.src_dark + "')";
                        } else {
                            icon.style.background = "url('" + item.icon.src + "')";
                        }
                        icon.style.backgroundRepeat = "no-repeat";
                        icon.style.backgroundSize = "18px";

                        // user custom styles
                        if (item.icon.style)
                            icon.style.cssText += item.icon.style;

                        menu_item.appendChild(icon);
                        break;
                    case "svg_path":
                        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                        svg.style.margin = "5px 0px 5px 8px";
                        svg.setAttribute('width', '18');
                        svg.setAttribute('height', '18');
                        svg.innerHTML = '<path d="' + item.icon.src + '" stroke="' + (item.color ? item.color : (darkmode ? color_dark : color)) + '"/>';
                        menu_item.appendChild(svg);
                        break;
                }
            }

            // Label
            const label = document.createElement("span");

            label.style.margin = "0 8px";
            //label.style.lineHeight = "29px";
            label.style.verticalAlign = "middle";

            label.innerHTML = item.label;
            menu_item.appendChild(label);

            return menu_item;
        }

        // Helpers
        static checkPosWithinScreen(el) {
            var parentOffsetLeft = el.offsetParent.dataset.left ? parseInt(el.offsetParent.dataset.left) : el.offsetParent.offsetLeft;
            var parentOffsetTop = el.offsetParent.dataset.top ? parseInt(el.offsetParent.dataset.top) : el.offsetParent.offsetTop;

            if (parentOffsetLeft + el.offsetLeft + el.offsetWidth > window.innerWidth) {
                var offsetLeft = window.innerWidth - parentOffsetLeft - el.offsetWidth - 3;
                el.style.left = offsetLeft + "px";
                el.dataset.left = offsetLeft + parentOffsetLeft;
            } else {
                el.dataset.left = el.offsetLeft + parentOffsetLeft;
            }

            if (parentOffsetTop + el.offsetTop + el.offsetHeight > window.innerHeight) {
                var offsetTop = window.innerHeight - parentOffsetTop - el.offsetHeight - 3;
                el.style.top = offsetTop + "px";
                el.dataset.top = offsetTop + parentOffsetTop;
            } else {
                el.dataset.top = el.offsetTop + parentOffsetTop;
            }

            return true;
        }

        static removeMenu() {
            try {
                var cms = document.getElementsByName("PopupMenu");
                cms.forEach(el => {
                    document.body.removeChild(el);
                });

                document.removeEventListener("click", removeMenu);
            } catch (error) {
            }
        }
    }

    function isDarkMode() {
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            // Dark Mode ist aktiviert
            return true;
        } else {
            // Dark Mode ist nicht aktiviert
            return false;
        }
    }
</script>

</html>
